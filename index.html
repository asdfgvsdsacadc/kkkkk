<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Nebula Christmas Tree - Interactive Wish</title>
  
  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- [修改] 更换为更稳定的 Babel 源 (Cloudflare cdnjs) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.5/babel.min.js"></script>

  <!-- Global Styles -->
  <style>
    /* 修复手机端高度问题，防止地址栏遮挡 */
    body, html { 
      margin: 0; 
      padding: 0; 
      width: 100%; 
      height: 100%; 
      height: 100dvh; /* 适配移动端动态高度 */
      overflow: hidden; 
      background-color: #050505; 
      touch-action: none; /* 禁止手机端默认触摸行为 */
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }
    #root { 
      width: 100%; 
      height: 100%; 
    }
    /* 隐藏滚动条 */
    ::-webkit-scrollbar {
      display: none;
    }
    
    /* [新增] 加载提示样式 */
    #loading-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #ff69b4;
      font-size: 1.2rem;
      font-family: monospace;
      z-index: 9999;
      pointer-events: none;
      animation: pulse 1.5s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 0.5; }
      50% { opacity: 1; }
    }
  </style>

  <!-- Import Map -->
  <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react/jsx-runtime": "https://esm.sh/react@18.2.0/jsx-runtime",
    "react-dom": "https://esm.sh/react-dom@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "three": "https://esm.sh/three@0.160.0",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?external=react,react-dom,three",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber",
    "gsap": "https://esm.sh/gsap@3.12.5",
    "postprocessing": "https://esm.sh/postprocessing@6.35.2?external=three",
    "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber,postprocessing"
  }
}
</script>
</head>
<body>
  <!-- [新增] 加载提示 -->
  <div id="loading-text">Loading Magic...</div>
  <div id="root"></div>

  <script type="text/babel" data-type="module">
    import React, { useState, useRef, useMemo, useLayoutEffect, useEffect, Suspense } from 'react';
    import { createRoot } from 'react-dom/client';
    import * as THREE from 'three';
    import { Canvas, useFrame, useThree } from '@react-three/fiber';
    import { OrbitControls, Environment, ContactShadows } from '@react-three/drei';
    import { EffectComposer, Bloom } from '@react-three/postprocessing';
    import gsap from 'gsap';

    // 移除加载提示函数
    const removeLoadingText = () => {
        const loader = document.getElementById('loading-text');
        if (loader) loader.style.display = 'none';
    };

    // --- 检测是否为移动端 ---
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;

    // --- 动态调整性能参数 (修复版) ---
    // 手机端粒子数量稍微增加到 900
    const ITEM_COUNT = isMobile ? 900 : 2200; 
    const RIBBON_SEGMENTS = isMobile ? 200 : 600; 
    // 手机端爱心粒子数量增加到 5000
    const HEART_PARTICLE_COUNT = isMobile ? 5000 : 15000;
    const STAR_COUNT = isMobile ? 800 : 2000;
    
    // Bloom 设置
    const BLOOM_THRESHOLD = isMobile ? 0.9 : 1.1;
    const BLOOM_INTENSITY = isMobile ? 1.5 : 1.8;

    const TREE_HEIGHT = 14;
    const MAX_RADIUS = 5.5;

    // --- TYPES & CONSTANTS ---
    const ParticleShape = {
      Sphere: 'Sphere',
      Box: 'Box',
      Plane: 'Plane',
      Light: 'Light',
      Leaf: 'Leaf',
      Ribbon: 'Ribbon',
      Heart: 'Heart'
    };

    const PALETTE = [
      '#FFD700', '#C41E3A', '#C0C0C0', '#FFFFFF', '#FF4500',
    ];

    const GREEN_PALETTE = [
      '#006400', '#228B22', '#32CD32', '#2E8B57', '#008000',
    ];

    const WISHES = [
      { id: 1, title: "Only You", text: "Under the mistletoe or the stars, my only wish is you." },
      { id: 2, title: "Guiding Light", text: "May your Christmas be as bright as the lights guiding me to you." },
      { id: 3, title: "The Gift", text: "The best gift this year isn't under the tree, it's holding your hand." },
      { id: 4, title: "Warmth", text: "Snowflakes melt, but my love for you warms the coldest winter night." },
      { id: 5, title: "Spark", text: "Every Christmas light reminds me of the spark in your eyes." },
      { id: 6, title: "Embrace", text: "Wrapped in your arms is the only place I want to be this holiday." },
      { id: 7, title: "Magic", text: "You are the magic that makes my Christmas sparkle." },
      { id: 8, title: "Frozen Time", text: "Wishing for a moment frozen in time, just you and me and the falling snow." },
      { id: 9, title: "Heartbeat", text: "My heart beats in rhythm with the Christmas bells, calling your name." },
      { id: 10, title: "Starlight", text: "Let's make a memory tonight that will outshine the brightest star." },
    ];

    // 1. StarField
    const StarField = () => {
      const mesh = useRef(null);

      const particles = useMemo(() => {
        const temp = new Float32Array(STAR_COUNT * 3);
        for (let i = 0; i < STAR_COUNT; i++) {
          const x = (Math.random() - 0.5) * 100;
          const y = (Math.random() - 0.5) * 100;
          const z = (Math.random() - 0.5) * 100;
          temp[i * 3] = x;
          temp[i * 3 + 1] = y;
          temp[i * 3 + 2] = z;
        }
        return temp;
      }, []);

      useFrame((state, delta) => {
        if (mesh.current) {
          mesh.current.rotation.y -= delta * 0.05;
          mesh.current.rotation.x -= delta * 0.02;
        }
      });

      return (
        <points ref={mesh}>
          <bufferGeometry>
            <bufferAttribute
              attach="attributes-position"
              count={particles.length / 3}
              array={particles}
              itemSize={3}
            />
          </bufferGeometry>
          <pointsMaterial
            size={0.15}
            color="#ffffff"
            sizeAttenuation={true}
            transparent={true}
            opacity={0.8}
          />
        </points>
      );
    };

    // 2. Heart Shader & Particles
    const HeartShaderMaterial = {
      uniforms: {
        uTime: { value: 0 },
        uProgress: { value: 0 },
        uAlpha: { value: 0 },
        uColor1: { value: new THREE.Color('#FF007F') },
        uColor2: { value: new THREE.Color('#FFC0CB') },
        uPixelRatio: { value: 1.0 }, 
      },
      vertexShader: `
        uniform float uTime;
        uniform float uProgress;
        uniform vec3 uColor1;
        uniform vec3 uColor2;
        uniform float uPixelRatio;

        attribute vec3 aTarget;
        attribute float aRandom;
        varying vec3 vColor;
        varying float vAlpha;

        void main() {
          float startAt = aRandom * 0.4;
          float duration = 0.6;
          float t = smoothstep(startAt, startAt + duration, uProgress);

          vec3 noise = vec3(
             sin(uTime * 5.0 + position.x) * 0.2 * (1.0 - t),
             cos(uTime * 5.0 + position.y) * 0.2 * (1.0 - t),
             0.0
          );
          
          vec3 pos = mix(position, aTarget, t) + noise;

          vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
          gl_Position = projectionMatrix * mvPosition;

          float scale = mix(0.0, 1.0, t);
          gl_PointSize = (6.0 * aRandom + 2.0) * scale * (1.0 / -mvPosition.z) * uPixelRatio;

          vColor = mix(uColor1, uColor2, aRandom);
          vAlpha = t; 
        }
      `,
      fragmentShader: `
        uniform float uAlpha;
        varying vec3 vColor;
        varying float vAlpha;

        void main() {
          vec2 xy = gl_PointCoord.xy - 0.5;
          float dist = length(xy);
          if (dist > 0.5) discard;

          float strength = 1.0 - (dist * 2.0);
          strength = pow(strength, 1.5);

          vec3 hdrColor = vColor * 6.0;

          gl_FragColor = vec4(hdrColor, strength * uAlpha * vAlpha);
        }
      `
    };

    const HeartParticles = ({ isVisible }) => {
      const pointsRef = useRef(null);
      const materialRef = useRef(null);
      const { gl } = useThree(); 

      const { positions, targets, randoms } = useMemo(() => {
        const posArray = new Float32Array(HEART_PARTICLE_COUNT * 3);
        const targetArray = new Float32Array(HEART_PARTICLE_COUNT * 3);
        const randomArray = new Float32Array(HEART_PARTICLE_COUNT);

        let i = 0;
        while (i < HEART_PARTICLE_COUNT) {
          const range = 1.3;
          const x = (Math.random() - 0.5) * 2 * range;
          const y = (Math.random() - 0.5) * 2 * range;
          const z = (Math.random() - 0.5) * 2 * range;
          
          const a = x*x + (9/4)*(y*y) + z*z - 1;
          const term2 = x*x*z*z*z;
          const term3 = (9/80)*y*y*z*z*z;
          
          if (a*a*a - term2 - term3 < 0) {
            const s = 3.5;
            targetArray[i * 3] = x * s;
            targetArray[i * 3 + 1] = z * s + 2; 
            targetArray[i * 3 + 2] = y * s;
            
            posArray[i * 3] = 0; 
            posArray[i * 3 + 1] = 0;
            posArray[i * 3 + 2] = 0;

            randomArray[i] = Math.random();
            i++;
          }
        }
        return { positions: posArray, targets: targetArray, randoms: randomArray };
      }, []);

      useEffect(() => {
        if (materialRef.current) {
           materialRef.current.uniforms.uPixelRatio.value = Math.min(window.devicePixelRatio, 2);
        }
      }, []);

      useLayoutEffect(() => {
        if (isVisible) {
          gsap.killTweensOf(materialRef.current.uniforms.uProgress);
          gsap.killTweensOf(materialRef.current.uniforms.uAlpha);
          
          gsap.to(materialRef.current.uniforms.uProgress, {
            value: 1,
            duration: 3.0,
            ease: "power2.out"
          });
          gsap.to(materialRef.current.uniforms.uAlpha, {
            value: 1,
            duration: 1.5,
            delay: 0.1,
            ease: "power1.out"
          });
        } else {
          gsap.killTweensOf(materialRef.current.uniforms.uProgress);
          gsap.killTweensOf(materialRef.current.uniforms.uAlpha);

          gsap.to(materialRef.current.uniforms.uProgress, {
            value: 0,
            duration: 1.2,
            ease: "power2.in"
          });
          gsap.to(materialRef.current.uniforms.uAlpha, {
            value: 0,
            duration: 0.5,
            ease: "power1.out"
          });
        }
      }, [isVisible]);

      useFrame((state) => {
        if (materialRef.current) {
          materialRef.current.uniforms.uTime.value = state.clock.elapsedTime;
        }
        if (pointsRef.current && isVisible) {
            pointsRef.current.rotation.y = Math.sin(state.clock.elapsedTime * 0.5) * 0.1;
        }
      });

      return (
        <points ref={pointsRef}>
          <bufferGeometry>
            <bufferAttribute
              attach="attributes-position"
              count={positions.length / 3}
              array={positions}
              itemSize={3}
            />
            <bufferAttribute
              attach="attributes-aTarget"
              count={targets.length / 3}
              array={targets}
              itemSize={3}
            />
            <bufferAttribute
              attach="attributes-aRandom"
              count={randoms.length}
              array={randoms}
              itemSize={1}
            />
          </bufferGeometry>
          <shaderMaterial
            ref={materialRef}
            args={[HeartShaderMaterial]}
            transparent={true}
            depthWrite={false}
            blending={THREE.AdditiveBlending}
          />
        </points>
      );
    };

    // 3. Magic Tree
    const MagicTree = ({ isExploded }) => {
      const groupRef = useRef(null);
      const meshRefs = useRef([]);

      const sizeMultiplier = isMobile ? 1.6 : 1.0;

      const particles = useMemo(() => {
        const data = [];
        let idCounter = 0;

        for (let i = 0; i < ITEM_COUNT; i++) {
          const t = i / ITEM_COUNT;
          const angle = t * Math.PI * 50 + (Math.random() * 0.5); 
          const radius = (1 - t) * MAX_RADIUS;
          const randomOffset = 0.8; 
          const x = Math.cos(angle) * radius + (Math.random() - 0.5) * randomOffset;
          const z = Math.sin(angle) * radius + (Math.random() - 0.5) * randomOffset;
          const y = (t * TREE_HEIGHT) - (TREE_HEIGHT / 2);

          const initialPos = new THREE.Vector3(x, y, z);
          const rand = Math.random();
          let shape, color, scaleVec;

          if (rand < 0.65) {
            shape = ParticleShape.Leaf;
            color = GREEN_PALETTE[Math.floor(Math.random() * GREEN_PALETTE.length)];
            const s = (0.2 + Math.random() * 0.3) * sizeMultiplier; 
            scaleVec = new THREE.Vector3(s, s, s);
          } else if (rand < 0.80) {
            shape = ParticleShape.Light;
            const lightColors = ['#fffec4', '#ffeb3b', '#ff9800', '#ffffff'];
            color = lightColors[Math.floor(Math.random() * lightColors.length)];
            const s = (0.15 + Math.random() * 0.15) * sizeMultiplier; 
            scaleVec = new THREE.Vector3(s, s, s);
          } else {
            const geometryShapes = [ParticleShape.Sphere, ParticleShape.Box];
            shape = geometryShapes[Math.floor(Math.random() * geometryShapes.length)];
            color = PALETTE[Math.floor(Math.random() * PALETTE.length)];
            const s = (0.2 + Math.random() * 0.3) * sizeMultiplier; 
            scaleVec = new THREE.Vector3(s, s, s);
          }
          
          const explodeRadius = 25 + Math.random() * 25;
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos((Math.random() * 2) - 1);
          const ex = explodeRadius * Math.sin(phi) * Math.cos(theta);
          const ey = explodeRadius * Math.sin(phi) * Math.sin(theta);
          const ez = explodeRadius * Math.cos(phi);
          const explodedPos = new THREE.Vector3(ex, ey, ez);
          const rotation = new THREE.Euler(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);

          data.push({ id: idCounter++, shape, color, initialPos, explodedPos, rotation, scale: scaleVec });
        }

        const ribbons = 2;
        for (let r = 0; r < ribbons; r++) {
           const offsetPhase = (r * Math.PI); 
           for (let i = 0; i < RIBBON_SEGMENTS / ribbons; i++) {
              const t = i / (RIBBON_SEGMENTS / ribbons);
              const angle = (t * Math.PI * 12) + offsetPhase; 
              const radius = ((1 - t) * MAX_RADIUS) + 0.6; 
              const y = (t * TREE_HEIGHT) - (TREE_HEIGHT / 2);
              const x = Math.cos(angle) * radius;
              const z = Math.sin(angle) * radius;
              const initialPos = new THREE.Vector3(x, y, z);
              const explodeRadius = 30;
              const theta = Math.random() * Math.PI * 2;
              const phi = Math.acos((Math.random() * 2) - 1);
              const explodedPos = new THREE.Vector3(
                  explodeRadius * Math.sin(phi) * Math.cos(theta),
                  explodeRadius * Math.sin(phi) * Math.sin(theta),
                  explodeRadius * Math.cos(phi)
              );
              
              const nextAngle = ((t + 0.01) * Math.PI * 12) + offsetPhase;
              const nextRadius = ((1 - (t + 0.01)) * MAX_RADIUS) + 0.6;
              const nextY = ((t + 0.01) * TREE_HEIGHT) - (TREE_HEIGHT / 2);
              const dummyObj = new THREE.Object3D();
              dummyObj.position.copy(initialPos);
              dummyObj.lookAt(new THREE.Vector3(Math.cos(nextAngle)*nextRadius, nextY, Math.sin(nextAngle)*nextRadius));

              data.push({
                id: idCounter++,
                shape: ParticleShape.Ribbon,
                color: r === 0 ? '#FFD700' : '#C41E3A',
                initialPos,
                explodedPos,
                rotation: dummyObj.rotation.clone(),
                scale: new THREE.Vector3(0.15, 0.6, 1)
              });
           }
        }
        return data;
      }, []);

      useLayoutEffect(() => {
        if (!meshRefs.current) return;
        
        meshRefs.current.forEach((mesh, i) => {
          if (!mesh) return;
          const p = particles[i];

          gsap.killTweensOf(mesh.position);
          gsap.killTweensOf(mesh.rotation);
          gsap.killTweensOf(mesh.scale);

          if (isExploded) {
            gsap.to(mesh.position, {
              x: p.explodedPos.x,
              y: p.explodedPos.y,
              z: p.explodedPos.z,
              duration: 1.2 + Math.random() * 0.8,
              ease: "expo.out",
            });
            gsap.to(mesh.rotation, {
              x: p.rotation.x + Math.random() * 5,
              y: p.rotation.y + Math.random() * 5,
              z: p.rotation.z + Math.random() * 5,
              duration: 2.5,
              ease: "none"
            });
            if (p.shape === ParticleShape.Ribbon) {
               gsap.to(mesh.scale, { x: 0, y: 0, z: 0, duration: 0.6, ease: "power2.out" });
            }
          } else {
            gsap.to(mesh.position, {
              x: p.initialPos.x,
              y: p.initialPos.y,
              z: p.initialPos.z,
              duration: 2.2 + Math.random() * 0.4,
              ease: "expo.out", 
              delay: Math.random() * 0.15 
            });
            gsap.to(mesh.rotation, {
              x: p.rotation.x,
              y: p.rotation.y,
              z: p.rotation.z,
              duration: 2.0,
              ease: "expo.out"
            });
             if (p.shape === ParticleShape.Ribbon) {
               gsap.to(mesh.scale, { 
                 x: p.scale.x, 
                 y: p.scale.y, 
                 z: p.scale.z, 
                 duration: 2.0,
                 ease: "expo.out"
               });
            }
          }
        });
      }, [isExploded, particles]);

      useFrame((state, delta) => {
        if (groupRef.current) {
            const speed = isExploded ? 0.01 : 0.15;
            groupRef.current.rotation.y += delta * speed;
        }
      });

      const sphereGeo = useMemo(() => new THREE.SphereGeometry(1, 16, 16), []);
      const boxGeo = useMemo(() => new THREE.BoxGeometry(1, 1, 1), []);
      const leafGeo = useMemo(() => new THREE.TetrahedronGeometry(1, 0), []);
      const ribbonGeo = useMemo(() => new THREE.PlaneGeometry(1, 1), []);
      const octGeo = useMemo(() => new THREE.OctahedronGeometry(0.7, 0), []);

      useEffect(() => {
        return () => {
            sphereGeo.dispose();
            boxGeo.dispose();
            leafGeo.dispose();
            ribbonGeo.dispose();
            octGeo.dispose();
        };
      }, []);

      return (
        <group>
            <group ref={groupRef}>
                <mesh position={[0, TREE_HEIGHT / 2 + 0.5, 0]} geometry={octGeo}>
                    <meshStandardMaterial 
                        color="#FFD700" 
                        emissive="#FFD700" 
                        emissiveIntensity={isExploded ? 0 : 4} 
                        toneMapped={false} 
                    />
                </mesh>

                {particles.map((p, i) => {
                    let geometry;
                    let material;

                    if (p.shape === ParticleShape.Light) {
                        return (
                            <mesh
                                key={p.id}
                                ref={(el) => (meshRefs.current[i] = el)}
                                position={p.initialPos}
                                scale={[p.scale.x, p.scale.y, p.scale.z]}
                                geometry={sphereGeo}
                            >
                                <meshStandardMaterial 
                                    color={p.color} 
                                    emissive={p.color} 
                                    emissiveIntensity={3.0} 
                                    toneMapped={false} 
                                />
                            </mesh>
                        );
                    }

                    if (p.shape === ParticleShape.Leaf) {
                        geometry = leafGeo;
                        material = <meshStandardMaterial color={p.color} roughness={0.6} metalness={0.1} />;
                    } else if (p.shape === ParticleShape.Ribbon) {
                        geometry = ribbonGeo;
                        material = <meshStandardMaterial color={p.color} emissive={p.color} emissiveIntensity={0.5} roughness={0.2} metalness={0.9} side={THREE.DoubleSide} />;
                    } else if (p.shape === ParticleShape.Box) {
                        geometry = boxGeo;
                        material = <meshStandardMaterial color={p.color} roughness={0.2} metalness={0.8} />;
                    } else {
                        geometry = sphereGeo;
                        material = <meshStandardMaterial color={p.color} roughness={0.2} metalness={0.8} />;
                    }

                    return (
                        <mesh
                            key={p.id}
                            ref={(el) => (meshRefs.current[i] = el)}
                            position={p.initialPos}
                            rotation={p.rotation}
                            scale={[p.scale.x, p.scale.y, p.scale.z]}
                            geometry={geometry}
                        >
                            {material}
                        </mesh>
                    );
                })}
            </group>
            <HeartParticles isVisible={isExploded} />
        </group>
      );
    };

    // 4. Experience
    const Experience = ({ isExploded }) => {
      // 手机端视角拉近到 18
      const camPos = isMobile ? [0, 2, 18] : [0, 2, 14];

      // 首次渲染移除加载文字
      useEffect(() => {
         removeLoadingText();
      }, []);

      return (
        <div className="w-full h-full">
          <Canvas
            camera={{ position: camPos, fov: 60 }}
            dpr={[1, 2]} 
            gl={{ 
                antialias: false,
                alpha: false,
                stencil: false,
                depth: true,
                powerPreference: "high-performance"
            }} 
          >
            <Suspense fallback={null}>
              <color attach="background" args={['#020202']} />
              
              <OrbitControls 
                enablePan={false}
                enableDamping={true}
                dampingFactor={0.05}
                minDistance={5}
                maxDistance={35}
              />

              <ambientLight intensity={0.2} />
              <spotLight
                position={[10, 10, 10]}
                angle={0.5}
                penumbra={1}
                intensity={50}
                castShadow
              />
              <pointLight position={[-10, -5, -10]} intensity={20} color="#004400" />
              
              <Environment preset="night" />

              <StarField />
              <MagicTree isExploded={isExploded} />
              
              <ContactShadows 
                opacity={0.5} 
                scale={20} 
                blur={2.5} 
                far={10} 
                resolution={256} 
                color="#000000" 
              />

              <EffectComposer disableNormalPass>
                <Bloom 
                    luminanceThreshold={BLOOM_THRESHOLD} 
                    mipmapBlur 
                    intensity={BLOOM_INTENSITY} 
                    radius={0.7}
                />
              </EffectComposer>
            </Suspense>
          </Canvas>
        </div>
      );
    };

    // 5. Main App
    const App = () => {
      const [isExploded, setIsExploded] = useState(false);
      const [selectedWishIndex, setSelectedWishIndex] = useState(0);
      const [textOpacity, setTextOpacity] = useState(1);

      const toggleExplosion = () => {
        setIsExploded((prev) => !prev);
      };

      const handleWishChange = (direction) => {
        setTextOpacity(0);
        setTimeout(() => {
          setSelectedWishIndex((prev) => {
            if (direction === 'next') {
              return (prev + 1) % WISHES.length;
            } else {
              return (prev - 1 + WISHES.length) % WISHES.length;
            }
          });
          setTextOpacity(1);
        }, 400); 
      };

      return (
        <div className="relative w-full h-full bg-black overflow-hidden font-sans select-none">
          {/* 3D Scene */}
          <div className="absolute inset-0 z-0">
            <Experience isExploded={isExploded} />
          </div>

          {/* Text */}
          <div className="absolute top-[15%] md:top-[20%] left-0 w-full z-10 pointer-events-none px-4 flex justify-center">
            <div 
              className={`
                max-w-4xl text-center transition-all duration-700 ease-in-out
                ${isExploded ? 'scale-110' : 'scale-100'}
              `}
              style={{ opacity: isExploded ? textOpacity : textOpacity * 0.7 }}
            >
              <p className="font-serif italic text-xl md:text-5xl text-pink-100 drop-shadow-[0_0_15px_rgba(255,105,180,0.8)] leading-relaxed">
                “ {WISHES[selectedWishIndex].text} ”
              </p>
            </div>
          </div>

          {/* UI Header */}
          <div className="absolute inset-0 z-10 pointer-events-none flex flex-col justify-between p-6 md:p-8">
            <header className="text-center md:text-left pointer-events-auto">
              <h1 className="text-3xl md:text-6xl font-bold text-white tracking-tighter drop-shadow-lg">
                <span className="text-red-500">MERRY</span> <span className="text-green-500">CHRISTMAS</span>
              </h1>
              <p className="text-gray-400 mt-2 text-xs md:text-sm tracking-widest uppercase">Interactive 3D Experience</p>
            </header>
            <div className="text-center md:text-right hidden md:block">
               <p className="text-xs text-gray-500">Drag to Rotate • Scroll to Zoom</p>
            </div>
          </div>

          {/* Sidebar Toggle */}
          <div className="absolute right-4 md:right-8 top-1/2 -translate-y-1/2 z-30 pointer-events-none">
            <div className="pointer-events-auto group relative flex items-center justify-center">
              <div className="
                bg-white/10 backdrop-blur-xl border border-white/20 
                shadow-[0_0_20px_rgba(255,105,180,0.3)]
                transition-all duration-500 ease-[cubic-bezier(0.175,0.885,0.32,1.275)]
                w-12 h-12 md:w-14 md:h-14 rounded-full
                group-hover:w-64 md:group-hover:w-80 group-hover:h-16 md:group-hover:h-20 group-hover:rounded-[2rem]
                group-hover:bg-black/60 group-hover:border-pink-500/30
              "></div>

              <div className="absolute inset-0 flex items-center justify-center transition-all duration-300 group-hover:opacity-0 group-hover:scale-50">
                 <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" className="w-5 h-5 md:w-6 md:h-6 text-pink-400 animate-pulse">
                   <path d="M11.645 20.91l-.007-.003-.022-.012a15.247 15.247 0 01-.383-.218 25.18 25.18 0 01-4.244-3.17C4.688 15.36 2.25 12.174 2.25 8.25 2.25 5.322 4.714 3 7.688 3A5.5 5.5 0 0112 5.052 5.5 5.5 0 0116.313 3c2.973 0 5.437 2.322 5.437 5.25 0 3.925-2.438 7.111-4.739 9.256a25.175 25.175 0 01-4.244 3.17 15.247 15.247 0 01-.383.219l-.022.012-.007.004-.003.001a.752.752 0 01-.704 0l-.003-.001z" />
                 </svg>
              </div>

              <div className="absolute inset-0 flex items-center justify-between px-4 md:px-6 opacity-0 scale-90 group-hover:opacity-100 group-hover:scale-100 transition-all duration-500 delay-75">
                 <button 
                    onClick={() => handleWishChange('prev')}
                    className="p-2 rounded-full hover:bg-white/10 text-gray-300 hover:text-white transition-colors"
                 >
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={2} stroke="currentColor" className="w-4 h-4 md:w-5 md:h-5">
                      <path strokeLinecap="round" strokeLinejoin="round" d="M15.75 19.5L8.25 12l7.5-7.5" />
                    </svg>
                 </button>

                 <div className="flex flex-col items-center justify-center w-full px-1 overflow-hidden">
                    <span className="text-[8px] md:text-[10px] text-pink-400 uppercase tracking-[0.2em] font-bold mb-0.5">
                       WISH {selectedWishIndex + 1}
                    </span>
                    <span className="text-xs md:text-base text-white font-serif italic truncate w-32 md:w-full text-center">
                       {WISHES[selectedWishIndex].title}
                    </span>
                 </div>

                 <button 
                    onClick={() => handleWishChange('next')}
                    className="p-2 rounded-full hover:bg-white/10 text-gray-300 hover:text-white transition-colors"
                 >
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={2} stroke="currentColor" className="w-4 h-4 md:w-5 md:h-5">
                      <path strokeLinecap="round" strokeLinejoin="round" d="M8.25 4.5l7.5 7.5-7.5 7.5" />
                    </svg>
                 </button>
              </div>
            </div>
          </div>

          {/* Action Button */}
          <div className="absolute bottom-8 md:bottom-12 left-1/2 -translate-x-1/2 z-20 w-full flex justify-center">
            <button
              onClick={toggleExplosion}
              className={`
                relative group px-8 py-4 md:px-10 md:py-5 bg-white/10 backdrop-blur-xl border border-white/20 
                rounded-full text-white font-bold tracking-[0.2em] uppercase transition-all duration-300
                hover:bg-white/20 hover:scale-105 active:scale-95 shadow-[0_0_30px_rgba(255,255,255,0.15)]
                overflow-hidden text-sm md:text-base
              `}
            >
              <span className="relative z-10">
                {isExploded ? "Gather Magic" : "Make a Wish"}
              </span>
              <div className="absolute inset-0 bg-gradient-to-r from-transparent via-white/10 to-transparent -translate-x-full group-hover:translate-x-full transition-transform duration-700 ease-in-out"></div>
              <div className={`absolute inset-0 rounded-full bg-gradient-to-r from-pink-600/50 to-purple-600/50 opacity-0 ${isExploded ? 'opacity-100' : 'group-hover:opacity-100'} transition-opacity duration-500 blur-md`}></div>
            </button>
          </div>
        </div>
      );
    };

    const rootElement = document.getElementById('root');
    const root = createRoot(rootElement);
    root.render(<App />);
  </script>
</body>
</html>